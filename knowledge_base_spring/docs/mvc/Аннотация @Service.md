# Аннотация @Service (Spring)

## Что это такое?

`@Service` — это специальная аннотация в Spring, которой помечают классы, реализующие бизнес-логику приложения (например, обработку заказов, подсчёт зарплаты, работу с данными, но не напрямую с базой).

---

## Зачем нужна?
- Помогает Spring автоматически находить и регистрировать такие классы
- Разделяет логику приложения на слои (Controller → Service → DAO)
- Упрощает тестирование и поддержку кода

---

## Где используется?
- В классах, которые отвечают за обработку данных, но не за работу с базой напрямую (для этого есть @Repository)
- Обычно сервисы вызываются из контроллеров

---

## Пример кода с пояснениями
```java
import org.springframework.stereotype.Service;

@Service // Помечает класс как сервис (бизнес-логика)
public class EmployeeService {
    public int calculateSalary(int base, int bonus) {
        return base + bonus; // Простая бизнес-логика
    }
}
```

---

## Как это работает в приложении?
- Контроллер вызывает методы сервиса
- Сервис реализует бизнес-логику (например, считает зарплату)
- Если нужно получить/сохранить данные — сервис обращается к DAO (или репозиторию)

---

## Мини-глоссарий
- **Бизнес-логика** — правила и операции, которые отражают суть работы приложения (например, как считать скидку)
- **Сервис (Service)** — класс, реализующий бизнес-логику
- **DAO/Repository** — классы для работы с базой данных
- **Контроллер (Controller)** — принимает запросы пользователя

---

## Советы новичку
- Не пихай всю логику в контроллер — выноси её в сервисы
- Сервис — это не просто "класс для всего", а слой для бизнес-операций
- Для работы с БД используй отдельные классы с аннотацией @Repository

---

Аннотация @Service помечает класс, содержащий бизнес-логику

В иерархии компонентов приложения Service является соеденительным звеном между Controller-ом и DAO (это компонент, который отвечает за работу с базой данных. Он изолирует всю логику доступа к данным от бизнес-логики и контроллеров, обеспечивая чистую архитектуру и тестируемость.)

Controller - это метод, который определяет логику работы приложения, когда клиент переходит на ту или иную страницу

```Java
import org.springframework.web.bind.annotation.*;

@RestController
public class HelloController {

    @GetMapping("/hello")
    public String sayHello() {
        return "Привет, это контроллер на Spring!";
    }
}
```

> В данном, случае когда на клиенте будет будет осущетвслен переход по пути /hello, то ему будет возвращен ответ "Привет, это контроллер на Spring!" <br> @Service - это специализированный @Component. Данный класс, в своих методах используем методы из DAO. <br> При поиске компонентов, Spring так же будет регистрировать все классы с аннотацией @Service в Spring Container-е

**Взаимодействие слоёв (схема):**

```
[Controller] ---> [Service] ---> [DAO/Repository] ---> [База данных]
```

- Controller принимает запрос пользователя
- Service реализует бизнес-логику
- DAO/Repository работает с базой данных

Метод в Secvice

```Java
@Service
public class EmployeeServiceImpl implements EmployeeService {

    @Autowired
    private EmployeeDAOImpl employeeDAO;

    @Override
    @Transactional
    public List<Employee> getAllEmployees() {
        return employeeDAO.getAllEmployees();
    }
}
```

> В данном случае, у нас есть EmployeeDAOImpl, который реализует всю логику работы с БД. У него есть метод, который получет всех работников и в Secvice мне жедаем одноименный метод и возвращаем результат работы метода .getAllEmployees() из EmployeeDAOImpl <br> То есть, в контроллерре мы обращаемся к сервису, а сервис обращается к ДАО <br> Так же, аннотацию @Transactional мы переносим в класс Service